question_number,topic,difficulty,slug,question,correct_approach,incorrect_approach_1,incorrect_approach_2
70,Dynamic Programming,Easy,climbing-stairs,You are climbing a staircase with n steps. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Given n will be a positive integer.,"Use dynamic programming to build a solution bottom-up. Create an array dp where dp[i] represents the number of ways to reach step i. Initialize dp[1] = 1 and dp[2] = 2. For i from 3 to n, dp[i] = dp[i-1] + dp[i-2].","Use recursion to calculate the number of ways. For each step, recursively calculate the ways for n-1 and n-2 steps, then sum them up. Base cases: if n = 1, return 1; if n = 2, return 2.",Use a mathematical formula. The number of ways to climb n stairs is equal to the (n+1)th Fibonacci number. Calculate this number using the formula: Fib(n+1) = (1/√5) * (((1+√5)/2)^(n+1) - ((1-√5)/2)^(n+1)).
300,Dynamic Programming,Medium,longest-increasing-subsequence,"Given an integer array nums, find the length of the longest strictly increasing subsequence. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements.","Use dynamic programming. Create an array dp where dp[i] represents the length of the longest increasing subsequence ending at index i. Iterate through the array, updating dp[i] by comparing nums[i] with previous elements and taking the maximum value.",Sort the array and count the number of unique elements. This approach assumes that the longest increasing subsequence is always the sorted version of the array without duplicates.,"Use a greedy approach. Iterate through the array, keeping track of the current increasing sequence. If the next number is larger, add it to the sequence; otherwise, start a new sequence."
78,Backtracking,Easy,subsets,"Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.","Use backtracking to generate all subsets. Start with an empty subset and recursively add each element, exploring two choices: including the current element or not. This process builds all possible combinations.","Sort the array and use a sliding window approach. Start with an empty subset, then create subsets of size 1, 2, and so on, using the sliding window to generate combinations.","Use bit manipulation. Generate all binary numbers from 0 to 2^n - 1, where n is the array length. Each binary number represents a subset, with 1s indicating included elements."
77,Backtracking,Easy,combinations,"Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n]. The combinations should be returned as a list of lists, where each inner list represents a unique combination. The order of combinations and numbers within each combination doesn't matter.","Use backtracking to generate all combinations. Start with an empty list and recursively add numbers from 1 to n. When the list size reaches k, add it to the result. Use a loop to avoid duplicates and maintain the ascending order of numbers in each combination.","Generate all possible permutations of k numbers from 1 to n using a recursive function. Then, remove duplicates by converting each permutation to a set and back to a list. Finally, sort the resulting list of combinations.",Create a list of all numbers from 1 to n. Use itertools.combinations() to generate all possible combinations of k numbers. Convert the result to a list of lists and return it as the final answer.
104,Binary Tree,Easy,maximum-depth-of-binary-tree,"Given the root of a binary tree, return its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. A leaf is a node with no children.","Use recursive depth-first search (DFS). For each node, return 1 plus the maximum of the depths of its left and right subtrees. If a node is null, return 0.","Use breadth-first search (BFS) with a queue. Enqueue the root, then process nodes level by level. Count the number of levels processed and return that count.",Traverse the tree using in-order traversal. Keep track of the current depth at each step. Return the maximum depth encountered during the traversal.
144,Binary Tree,Easy,binary-tree-preorder-traversal,"Given the root of a binary tree, return the preorder traversal of its nodes' values. Preorder traversal visits the root, then the left subtree, and finally the right subtree. Return the values in a list.","Use a recursive approach. Visit the root node, add its value to the result list, then recursively traverse the left subtree, followed by the right subtree. Return the final list of values.","Perform a level-order traversal using a queue. Start with the root, enqueue its children, and continue until the queue is empty. Add each node's value to the result list as it's dequeued.","Use an iterative inorder traversal with a stack. Push nodes onto the stack, starting with the root. Pop nodes, add their values to the result, and push their right and left children onto the stack."
141,Data Structures,Easy,linked-list-cycle,"Given the head of a linked list, determine if the list has a cycle. A cycle occurs when a node in the list points back to a previous node, creating a loop. Return true if a cycle exists, and false otherwise. The linked list may be empty or have only one node.","Use two pointers, slow and fast. Move slow one step and fast two steps at a time. If there's a cycle, they'll meet. If fast reaches the end or becomes null, there's no cycle.","Traverse the linked list and store each node's address in a set. If a node's address is already in the set, return true. Otherwise, continue until the end is reached.","Count the number of nodes in the linked list. If the count exceeds a predetermined threshold (e.g., 10000), assume there's a cycle. Otherwise, return false."
160,Data Structures,Easy,intersection-of-two-linked-lists,"Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null. The test cases are generated such that there are no cycles anywhere in the entire linked structure.","Use two pointers, one for each list. Move both pointers until they reach the end. When a pointer reaches the end, move it to the head of the other list. Continue until both pointers meet at the intersection or both become null.","Compare each node of listA with every node of listB. If a match is found, return that node. If no match is found after comparing all nodes, return null.","Calculate the length of both lists. Find the difference in length. Move the pointer of the longer list by the difference. Then, move both pointers simultaneously until they meet or reach the end."
