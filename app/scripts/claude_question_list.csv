question_number,topic,difficulty,question,correct_approach,incorrect_approach_1,incorrect_approach_2,same_topic_option_1,same_topic_option_2,same_topic_option_3
704,Binary Search,Easy,"Given a sorted array of integers nums and an integer target, write a function to search target in nums. If target exists, return its index. Otherwise, return -1. The algorithm must have O(log n) runtime complexity.","Implement binary search by repeatedly dividing the search interval in half. Initialize two pointers, left and right, to the start and end of the array. While left <= right, calculate mid, compare nums[mid] with target, and adjust pointers accordingly.","Use a linear search algorithm to iterate through the array from left to right. Compare each element with the target value. If found, return the index; if not found after checking all elements, return -1.","Sort the array in descending order. Use binary search, but always move the left pointer to mid + 1 when nums[mid] > target, and move the right pointer to mid - 1 when nums[mid] < target.","Implement binary search by repeatedly dividing the search interval in half. Initialize two pointers, left and right, to the start and end of the array. While left <= right, calculate mid, compare nums[mid] with target, and adjust pointers accordingly.","Use a linear search algorithm to iterate through the array from left to right. Compare each element with the target value. If found, return the index; if not found after checking all elements, return -1.","Sort the array in descending order. Use binary search, but always move the left pointer to mid + 1 when nums[mid] > target, and move the right pointer to mid - 1 when nums[mid] < target."
153,Binary Search,Medium,"Given a sorted array that has been rotated between 1 and n times, find the minimum element. The array may contain duplicate values. Assume no duplicate exists in the array and the rotation is in the range [0, n]. Return the minimum element in the array.","Use binary search. Compare mid with right element. If mid > right, minimum is in right half. If mid < right, minimum is in left half including mid. If equal, decrement right pointer. Continue until left and right pointers meet.",Iterate through the array linearly from left to right. Keep track of the smallest element seen so far. Return the smallest element after completing the iteration.,Sort the array in ascending order using a sorting algorithm like quicksort or mergesort. Return the first element of the sorted array as the minimum element.,"Use binary search. Compare mid with right element. If mid > right, minimum is in right half. If mid < right, minimum is in left half including mid. If equal, decrement right pointer. Continue until left and right pointers meet.",Iterate through the array linearly from left to right. Keep track of the smallest element seen so far. Return the smallest element after completing the iteration.,Sort the array in ascending order using a sorting algorithm like quicksort or mergesort. Return the first element of the sorted array as the minimum element.
26,Two Pointers,Easy,"Given a sorted array of integers, remove duplicates in-place such that each element appears only once and return the new length. Do not allocate extra space for another array; you must do this by modifying the input array in-place with O(1) extra memory.",Use two pointers: one to iterate through the array and another to keep track of the position for the next unique element. Compare adjacent elements and move unique ones to the front of the array.,"Create a new array to store unique elements. Iterate through the original array, adding elements to the new array only if they're not already present. Return the length of the new array.","Sort the array in descending order. Iterate through the sorted array, removing elements that are the same as the previous one. Return the length of the modified array.",Use two pointers: one to iterate through the array and another to keep track of the position for the next unique element. Compare adjacent elements and move unique ones to the front of the array.,"Create a new array to store unique elements. Iterate through the original array, adding elements to the new array only if they're not already present. Return the length of the new array.","Sort the array in descending order. Iterate through the sorted array, removing elements that are the same as the previous one. Return the length of the modified array."
15,Two Pointers,Medium,"Given an integer array nums, find all unique triplets in the array which give the sum of zero. The solution set must not contain duplicate triplets. Return the triplets in any order.","Sort the array. For each element, use two pointers to find pairs that sum to its negation. Skip duplicates to avoid repeating triplets. Time complexity: O(n^2).","Use three nested loops to check all possible triplets. If a triplet sums to zero, add it to the result set. Remove duplicates from the result set at the end.","Create a hash set of all numbers. For each pair of numbers, check if their negation exists in the set. If found, add the triplet to the result list.","Sort the array. For each element, use two pointers to find pairs that sum to its negation. Skip duplicates to avoid repeating triplets. Time complexity: O(n^2).","Use three nested loops to check all possible triplets. If a triplet sums to zero, add it to the result set. Remove duplicates from the result set at the end.","Create a hash set of all numbers. For each pair of numbers, check if their negation exists in the set. If found, add the triplet to the result list."
20,Stack,Easy,"Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if open brackets are closed by the same type of brackets, and open brackets are closed in the correct order.","Use a stack to keep track of opening brackets. When encountering a closing bracket, check if it matches the most recent opening bracket on the stack. If it does, pop the opening bracket. If the stack is empty at the end, the string is valid.","Count the number of opening and closing brackets. If the counts match for each type of bracket, consider the string valid. This approach doesn't consider the order of brackets.","Use a queue to store opening brackets. When encountering a closing bracket, check if it matches the first element in the queue. If it does, remove the first element. If the queue is empty at the end, the string is valid.","Use a stack to keep track of opening brackets. When encountering a closing bracket, check if it matches the most recent opening bracket on the stack. If it does, pop the opening bracket. If the stack is empty at the end, the string is valid.","Count the number of opening and closing brackets. If the counts match for each type of bracket, consider the string valid. This approach doesn't consider the order of brackets.","Use a queue to store opening brackets. When encountering a closing bracket, check if it matches the first element in the queue. If it does, remove the first element. If the queue is empty at the end, the string is valid."
155,Stack,Medium,"Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class with methods push(val), pop(), top(), and getMin(). All operations should be performed in O(1) time complexity.","Use two stacks: one for regular stack operations and another to keep track of minimum values. When pushing, update the min stack if the new value is smaller or equal to the current minimum. When popping, remove from both stacks if the popped value equals the current minimum.",Use a single stack and a variable to store the minimum value. Update the minimum when pushing or popping elements. Retrieve the minimum by iterating through the stack each time getMin() is called.,"Implement the stack as a linked list. Store the minimum value at each node. When pushing, update the minimum if the new value is smaller. When popping, recalculate the minimum by traversing the list.","Use two stacks: one for regular stack operations and another to keep track of minimum values. When pushing, update the min stack if the new value is smaller or equal to the current minimum. When popping, remove from both stacks if the popped value equals the current minimum.",Use a single stack and a variable to store the minimum value. Update the minimum when pushing or popping elements. Retrieve the minimum by iterating through the stack each time getMin() is called.,"Implement the stack as a linked list. Store the minimum value at each node. When pushing, update the minimum if the new value is smaller. When popping, recalculate the minimum by traversing the list."
104,Binary Tree,Easy,"Given the root of a binary tree, return its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. A leaf is a node with no children.","Use recursive depth-first search (DFS). For each node, return 1 plus the maximum of the depths of its left and right subtrees. If a node is null, return 0.","Use breadth-first search (BFS) with a queue. Enqueue the root, then process nodes level by level. Count the number of levels processed and return that count.",Traverse the tree using in-order traversal. Keep track of the current depth at each step. Return the maximum depth encountered during the traversal.,"Use recursive depth-first search (DFS). For each node, return 1 plus the maximum of the depths of its left and right subtrees. If a node is null, return 0.","Use breadth-first search (BFS) with a queue. Enqueue the root, then process nodes level by level. Count the number of levels processed and return that count.",Traverse the tree using in-order traversal. Keep track of the current depth at each step. Return the maximum depth encountered during the traversal.
94,Binary Tree,Medium,"Given the root of a binary tree, return the inorder traversal of its nodes' values. Inorder traversal visits the left subtree, then the root, and finally the right subtree. Implement this traversal iteratively or recursively, returning the values in a list.","Use a recursive approach. Define a helper function that takes a node and a result list. For each node, recursively traverse the left subtree, append the current node's value, then recursively traverse the right subtree. Return the final list.","Perform a level-order traversal using a queue. Start with the root node in the queue. For each node, add its value to the result list, then enqueue its left and right children if they exist. Continue until the queue is empty.","Use a pre-order traversal approach. Create a stack and push the root node. While the stack is not empty, pop a node, add its value to the result list, then push its right child followed by its left child if they exist.","Use a recursive approach. Define a helper function that takes a node and a result list. For each node, recursively traverse the left subtree, append the current node's value, then recursively traverse the right subtree. Return the final list.","Perform a level-order traversal using a queue. Start with the root node in the queue. For each node, add its value to the result list, then enqueue its left and right children if they exist. Continue until the queue is empty.","Use a pre-order traversal approach. Create a stack and push the root node. While the stack is not empty, pop a node, add its value to the result list, then push its right child followed by its left child if they exist."
102,BFS (Breadth-First Search),Medium,"Given the root of a binary tree, return the level order traversal of its nodes' values as a list of lists. Each inner list represents a level in the tree, from top to bottom.","Use a queue to perform BFS. Initialize the queue with the root node. For each level, process all nodes in the current queue, add their values to a level list, and enqueue their children. Repeat until the queue is empty.",Perform a depth-first search (DFS) using recursion. Keep track of the current level and add node values to corresponding level lists. Return the result after traversing the entire tree.,"Create a dictionary to store node values by their level. Traverse the tree using any method, updating the dictionary with node values and their corresponding levels. Sort the dictionary by level and return the result.","Use a queue to perform BFS. Initialize the queue with the root node. For each level, process all nodes in the current queue, add their values to a level list, and enqueue their children. Repeat until the queue is empty.",Perform a depth-first search (DFS) using recursion. Keep track of the current level and add node values to corresponding level lists. Return the result after traversing the entire tree.,"Create a dictionary to store node values by their level. Traverse the tree using any method, updating the dictionary with node values and their corresponding levels. Sort the dictionary by level and return the result."
127,BFS,Medium,"Given two words (beginWord and endWord) and a dictionary wordList, find the length of shortest transformation sequence from beginWord to endWord, such that only one letter can be changed at a time and each transformed word must exist in the wordList. Return 0 if no such sequence exists.","Use BFS to explore all possible transformations level by level. Create a queue, add beginWord, and track visited words. For each word, generate all possible transformations by changing one letter at a time. If a transformation exists in wordList, add it to the queue.","Use DFS to explore all possible transformations. Start from beginWord and recursively change one letter at a time. If the transformed word exists in wordList, continue the search. Keep track of the shortest path found so far.","Create a graph where words are nodes and edges connect words differing by one letter. Use Dijkstra's algorithm to find the shortest path from beginWord to endWord. Return the length of the path if found, otherwise return 0.","Use BFS to explore all possible transformations level by level. Create a queue, add beginWord, and track visited words. For each word, generate all possible transformations by changing one letter at a time. If a transformation exists in wordList, add it to the queue.","Use DFS to explore all possible transformations. Start from beginWord and recursively change one letter at a time. If the transformed word exists in wordList, continue the search. Keep track of the shortest path found so far.","Create a graph where words are nodes and edges connect words differing by one letter. Use Dijkstra's algorithm to find the shortest path from beginWord to endWord. Return the length of the path if found, otherwise return 0."
112,DFS (Depth-First Search),Easy,"Given the root of a binary tree and an integer targetSum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children.","Perform a DFS traversal, subtracting each node's value from targetSum. If a leaf node is reached and the remaining targetSum is 0, return true. If all paths are explored without finding a match, return false.","Use BFS to traverse the tree level by level. At each node, add its value to a running sum. If a leaf node is reached and the sum equals targetSum, return true. Otherwise, continue to the next level.","Calculate the sum of all node values in the tree. If the total sum is equal to targetSum, return true. Otherwise, return false. This approach assumes that any path can be considered, not just root-to-leaf paths.","Perform a DFS traversal, subtracting each node's value from targetSum. If a leaf node is reached and the remaining targetSum is 0, return true. If all paths are explored without finding a match, return false.","Use BFS to traverse the tree level by level. At each node, add its value to a running sum. If a leaf node is reached and the sum equals targetSum, return true. Otherwise, continue to the next level.","Calculate the sum of all node values in the tree. If the total sum is equal to targetSum, return true. Otherwise, return false. This approach assumes that any path can be considered, not just root-to-leaf paths."
200,DFS,Medium,"Given an m x n 2D binary grid representing a map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. Assume all four edges of the grid are surrounded by water.","Use depth-first search (DFS) to explore each land cell. When a '1' is found, increment the island count and use DFS to mark all connected land cells as visited. Continue this process for all cells in the grid.","Count the number of '1's in the grid and divide by 4, assuming each island is a perfect square shape. Round up the result to get the number of islands.","Use a sliding window technique to scan the grid. Count contiguous groups of '1's in each row and column separately, then take the average of these counts as the number of islands.","Use depth-first search (DFS) to explore each land cell. When a '1' is found, increment the island count and use DFS to mark all connected land cells as visited. Continue this process for all cells in the grid.","Count the number of '1's in the grid and divide by 4, assuming each island is a perfect square shape. Round up the result to get the number of islands.","Use a sliding window technique to scan the grid. Count contiguous groups of '1's in each row and column separately, then take the average of these counts as the number of islands."
70,Dynamic Programming,Easy,You are climbing a staircase with n steps. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Given n will be a positive integer.,"Use dynamic programming to build a solution bottom-up. Create an array dp where dp[i] represents the number of ways to reach step i. Initialize dp[1] = 1 and dp[2] = 2. For i from 3 to n, dp[i] = dp[i-1] + dp[i-2].","Use recursion to calculate the number of ways. For each step, recursively calculate the ways to reach it by taking either 1 or 2 steps. Return the sum of these two recursive calls.","Use a mathematical formula. The number of ways to climb n stairs is equal to the (n+1)th Fibonacci number. Calculate this number using the golden ratio formula: (φⁿ⁺¹ - (-φ)⁻ⁿ⁻¹) / √5, where φ = (1 + √5) / 2.","Use dynamic programming to build a solution bottom-up. Create an array dp where dp[i] represents the number of ways to reach step i. Initialize dp[1] = 1 and dp[2] = 2. For i from 3 to n, dp[i] = dp[i-1] + dp[i-2].","Use recursion to calculate the number of ways. For each step, recursively calculate the ways to reach it by taking either 1 or 2 steps. Return the sum of these two recursive calls.","Use a mathematical formula. The number of ways to climb n stairs is equal to the (n+1)th Fibonacci number. Calculate this number using the golden ratio formula: (φⁿ⁺¹ - (-φ)⁻ⁿ⁻¹) / √5, where φ = (1 + √5) / 2."
300,Dynamic Programming,Medium,"Given an integer array nums, find the length of the longest strictly increasing subsequence. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements.","Use dynamic programming. Create an array dp where dp[i] represents the length of the longest increasing subsequence ending at index i. Iterate through the array, updating dp[i] by comparing nums[i] with previous elements and taking the maximum value.",Sort the array and count the number of unique elements. This approach assumes that the longest increasing subsequence is always the sorted version of the array without duplicates.,"Use a greedy approach. Iterate through the array, keeping track of the current increasing sequence. If the next number is larger, add it to the sequence; otherwise, start a new sequence.","Use dynamic programming. Create an array dp where dp[i] represents the length of the longest increasing subsequence ending at index i. Iterate through the array, updating dp[i] by comparing nums[i] with previous elements and taking the maximum value.",Sort the array and count the number of unique elements. This approach assumes that the longest increasing subsequence is always the sorted version of the array without duplicates.,"Use a greedy approach. Iterate through the array, keeping track of the current increasing sequence. If the next number is larger, add it to the sequence; otherwise, start a new sequence."


704,Binary Search,Easy,"Given a sorted array of integers and a target value, implement a function to search for the target in the array using binary search. Return the index of the target if found, otherwise return -1. The array has no duplicates and is sorted in ascending order.","Initialize two pointers, left and right, to the start and end of the array. While left <= right, calculate mid, compare nums[mid] with target. If equal, return mid. If target is smaller, search left half; if larger, search right half. Return -1 if not found.","Iterate through the array from left to right, comparing each element with the target. If found, return the index; otherwise, return -1 after the loop ends.","Sort the array in descending order, then perform binary search. Initialize left and right pointers, calculate mid, and compare nums[mid] with target. Adjust pointers based on comparison. Return mid if found, -1 if not.","Use two pointers, left and right, starting at array ends. While left < right, move left pointer right if nums[left] < target, move right pointer left if nums[right] > target. Return left if nums[left] == target, else return -1.","Implement recursive binary search. Base case: if left > right, return -1. Calculate mid, compare nums[mid] with target. If equal, return mid. If target is smaller, recursively search left half; if larger, search right half."
153,Binary Search,Medium,"Given a sorted array that has been rotated between 1 and n times, find the minimum element. The array may contain duplicate values. Assume no duplicate exists in the array. The array will have at least one element. Return the minimum element in the array.","Use binary search. Compare mid with right element. If mid > right, minimum is in right half. If mid < right, minimum is in left half including mid. Update pointers accordingly. Continue until left pointer reaches minimum element.",Iterate through the array linearly and keep track of the smallest element encountered. Return the smallest element after completing the iteration.,"Sort the array in ascending order and return the first element, which will be the minimum element in the sorted array.","Use binary search. Compare mid with left element. If mid < left, minimum is in left half. If mid > left, minimum is in right half. Update pointers accordingly. Continue until left pointer reaches minimum element.","Use binary search. Compare mid with both left and right elements. If mid < left and mid < right, return mid. If mid > left, search right half. If mid < right, search left half. Update pointers accordingly."
26,Two Pointers,Easy,"Given a sorted array of integers, remove duplicates in-place such that each element appears only once. Return the number of unique elements. Do not allocate extra space for another array; modify the input array in-place with O(1) extra memory.",Use two pointers: one for iterating through the array and another for keeping track of the position to place unique elements. Compare adjacent elements and move unique ones to the front.,"Create a new array to store unique elements, then copy them back to the original array. Return the length of the new array.","Sort the array in descending order, then remove duplicates by shifting elements to the left when duplicates are found.","Use two pointers: one for iterating and one for unique elements. Skip duplicates by incrementing the iterator pointer until a different element is found, then swap with the unique pointer.","Use two pointers: one for iterating and one for unique elements. When a unique element is found, copy it to the position of the unique pointer, then increment both pointers."
