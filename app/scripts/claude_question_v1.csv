704,Binary Search,Easy,"Given a sorted array of integers nums and an integer target, write a function to search target in nums. If target exists, return its index. Otherwise, return -1. The algorithm must have O(log n) runtime complexity.","Implement binary search by repeatedly dividing the search interval in half. Initialize two pointers, left and right, to the start and end of the array. While left <= right, calculate mid, compare nums[mid] with target, and adjust pointers accordingly.","Iterate through the array linearly from start to end. For each element, check if it equals the target. If found, return its index; otherwise, continue to the next element. If the loop completes without finding the target, return -1.","Use a hash table to store each element's value as the key and its index as the value. Iterate through the array once to populate the hash table. Then, check if the target exists as a key in the hash table and return its corresponding value."
153,Binary Search,Medium,"Given a sorted array that has been rotated between 1 and n times, find the minimum element. The array may contain duplicate values. Assume no duplicate exists in the array and the rotation is in the range [0, n]. Return the minimum element in the array.","Use binary search. Compare mid with right element. If mid > right, minimum is in right half. If mid < right, minimum is in left half or mid itself. Continue narrowing search range until left and right pointers meet.","Iterate through the array linearly from left to right, keeping track of the smallest element seen so far. Return the smallest element after completing the iteration.",Sort the array in ascending order using a sorting algorithm like quicksort or mergesort. Return the first element of the sorted array as the minimum element.
26,Two Pointers,Easy,"Given a sorted array of integers, remove duplicates in-place such that each element appears only once and return the new length. Do not allocate extra space for another array; you must do this by modifying the input array in-place with O(1) extra memory.","Use two pointers: one to iterate through the array and another to keep track of the position for unique elements. Compare adjacent elements and move unique ones to the front of the array, updating the second pointer accordingly.","Create a new array to store unique elements. Iterate through the original array, adding elements to the new array only if they're not already present. Return the length of the new array.","Sort the array in descending order. Iterate through the sorted array, removing elements that are equal to their previous neighbor. Return the length of the modified array."
15,Two Pointers,Medium,"Given an integer array nums, find all unique triplets in the array which give the sum of zero. The solution set must not contain duplicate triplets. Return the triplets in any order.","Sort the array. For each element, use two pointers to find pairs in the remaining array that sum to its negation. Skip duplicates to avoid repeating triplets. Time complexity: O(n^2).","Use three nested loops to check all possible triplets. If a triplet sums to zero, add it to the result set. Remove duplicates from the result set at the end.","Create a hash set of all numbers. For each pair of numbers, check if their negated sum exists in the set. If found, add the triplet to the result list."
20,Stack,Easy,"Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if open brackets are closed by the same type of brackets, and open brackets are closed in the correct order.","Use a stack to keep track of opening brackets. When encountering a closing bracket, check if it matches the most recent opening bracket on the stack. If it does, pop the opening bracket. If the stack is empty at the end, the string is valid.","Count the number of opening and closing brackets. If the counts match for each type of bracket, consider the string valid. This approach doesn't consider the order of brackets.","Use a queue to store opening brackets. When encountering a closing bracket, check if it matches the first element in the queue. If it does, remove the first element. If the queue is empty at the end, the string is valid."
155,Stack,Medium,"Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class with methods push(val), pop(), top(), and getMin(). All operations should be performed in O(1) time complexity.","Use two stacks: one for regular stack operations and another to keep track of minimum values. When pushing, update the min stack if the new value is smaller or equal to the current minimum. When popping, remove from both stacks if the popped value equals the current minimum.","Use a single stack and store pairs of (value, current_min) for each element. When pushing, calculate the new minimum by comparing with the previous minimum. When popping, simply remove the top pair. This approach uses more space than necessary.","Use a single stack and maintain a separate variable for the minimum value. When pushing, update the minimum if necessary. When popping, recalculate the minimum by iterating through the entire stack. This approach violates the O(1) time complexity requirement for getMin()."
104,Binary Tree,Easy,"Given the root of a binary tree, return its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. A leaf is a node with no children.","Use recursive depth-first search (DFS). For each node, return 1 plus the maximum of the depths of its left and right subtrees. If a node is null, return 0.","Use breadth-first search (BFS) with a queue. Enqueue the root, then process nodes level by level. Count the number of levels processed and return that count.",Traverse the tree using in-order traversal. Keep track of the current depth at each step. Return the maximum depth encountered during the traversal.
94,Binary Tree,Medium,"Given the root of a binary tree, return the inorder traversal of its nodes' values. Inorder traversal visits the left subtree, then the root, and finally the right subtree. Implement this traversal iteratively or recursively, returning the values in a list.","Use a recursive approach. Define a helper function that takes a node and a result list. For each node, recursively traverse the left subtree, append the current node's value, then recursively traverse the right subtree. Return the final list.","Perform a level-order traversal using a queue. Start with the root node in the queue. For each node, add its value to the result list, then enqueue its left and right children if they exist. Continue until the queue is empty.","Use a pre-order traversal approach. Create a stack and push the root node. While the stack is not empty, pop a node, add its value to the result list, push its right child if it exists, then push its left child if it exists."
102,BFS (Breadth-First Search),"Medium (Note: This question is typically classified as Medium, not Easy)","Given the root of a binary tree, return the level order traversal of its nodes' values as a list of lists. Each inner list represents a level in the tree, from top to bottom.","Use a queue to perform BFS. Initialize the queue with the root node. For each level, process all nodes in the current queue, add their values to a level list, and enqueue their children. Repeat until the queue is empty.","Perform a depth-first search (DFS) using recursion. At each node, pass down the current level. Store node values in a global dictionary with level as key. After traversal, convert the dictionary to a list of lists.","Create a function to find the tree's height. Then, iterate from 0 to height, using a separate function to collect all nodes at each level. This function recursively traverses the tree, keeping track of the current depth."
127,BFS,Medium,"Given two words (beginWord and endWord) and a dictionary wordList, find the length of shortest transformation sequence from beginWord to endWord, such that only one letter can be changed at a time and each transformed word must exist in the wordList. Return 0 if no such sequence exists.","Use BFS to explore all possible transformations level by level. Create a queue, add beginWord, and track visited words. For each word, generate all possible transformations by changing one letter at a time. If a transformation exists in wordList, add it to the queue.","Use DFS to explore all possible transformations. Start from beginWord and recursively change one letter at a time. If the transformed word exists in wordList, continue the search. Keep track of the shortest path found so far.","Create a graph where words are nodes and edges connect words differing by one letter. Use Dijkstra's algorithm to find the shortest path from beginWord to endWord. Return the length of the path if found, otherwise return 0."
112,DFS (Depth-First Search),Easy,"Given the root of a binary tree and an integer targetSum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children.","Perform a DFS traversal, subtracting each node's value from targetSum. If a leaf node is reached and the remaining targetSum is 0, return true. If all paths are explored without finding a match, return false.","Calculate the sum of all node values in the tree. If the total sum equals targetSum, return true; otherwise, return false.","Use BFS to traverse the tree level by level. At each level, sum the node values. If the sum equals targetSum at any level, return true; otherwise, continue to the next level."
200,DFS,Medium,"Given an m x n 2D binary grid representing a map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. Assume all four edges of the grid are surrounded by water.","Use depth-first search (DFS) to explore each land cell ('1'). When a land cell is found, increment the island count and use DFS to mark all connected land cells as visited. Continue this process for all unvisited cells in the grid.","Count the number of '1's in the grid and divide by the total number of cells. This will give the ratio of land to water, which represents the number of islands.","Use a sliding window technique to scan the grid. Count contiguous groups of '1's as islands, resetting the count when encountering '0's. The final count represents the number of islands."